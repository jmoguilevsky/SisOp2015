#!/usr/bin/perl


use 5.010;
use strict;
use warnings;
use File::Spec::Functions;



my $mensajeAyuda = <<'END_MESSAGE';
Este es el mensaje de ayuda de AFLIST.pl.

Lista de opciones pusibles:

    * -h:
        Imprime este mensaje de ayuda.
    * -r:
        El resultado subconjunto de registros de llamadas sospechosas que 
        resulta luego de la aplicación de los filtros.

        Al comenzar pide una lista de archivos que usará para procesar. Estos 
        deben ser ingresados separados de espacios.

        Luego preguntará por filtros a aplicar. Se deberá ingresar a abreviación
        de cada, de a una por vez. Una vez ingresada esta abreviación, procederá
        a mostrar una lista de opciones las cuales serán. Si vuelve a elegir dos
        filtros iguales, siempre queda el mas restrictivo.

    * -s:


    * -w:
        Esta flag se puede usar opcionalmente con las flags -h y -r.
        grabar el resultado en un archivo con nombre a elección, pero no
        sobreescribir ningún resultado previo
END_MESSAGE


use constant MYENUM => qw(UNA VARIAS TODAS);
BEGIN {
    eval "use constant (MYENUM)[$_] => $_;" foreach 0..(MYENUM)-1;
}

my $false = 0;
my $true = 1;

# Hay que configurar estas variables
my $PROCDIR = $ENV{PROCDIR};
my $REPODIR = $ENV{REPODIR};
my $MAEDIR = $ENV{MAEDIR};

# say $PROCDIR;
# say $REPODIR;
# say $MAEDIR;

# Empieza el procesamiento de la entrada

sub error_parametros {
    say 'Parámetros inválidos, use -h para ver la ayuda.';
    exit 0;
}

sub una_varias_todas {

    my $succes;

    while ($true) {
        print 'Una, varia ó todas (ingrese la primera letra): ';

        my $in = readline(*STDIN);

        if ($in){
            chomp $in;
            my @options = split / /, $in;

            # say $options[0];

            if (scalar @options != 1){
                say 'Solo una opción es posible.';
            } else {
                $options[0] = lc $options[0];
                if ($options[0] eq 'u'){
                    return (MYENUM)[UNA];
                } elsif ($options[0] eq 'v') {
                    return (MYENUM)[VARIAS];
                } elsif ($options[0] eq 't') {
                    return (MYENUM)[TODAS];
                }
            }            
        } else {
            say '';
            say 'Debe ingresar por lo menos un caracter';
        }

    }
}



my $write = 0;
my $consulta = 0;
my $stats = 0;

my %params = map { $_ => 1 } @ARGV;


if (exists($params{'-h'})) { 
    if (scalar (@ARGV) !=1 ) {
        error_parametros();
        exit 1;
    }
    say $mensajeAyuda;
    exit 0;
}

# si llegamos hasta acá, la entrada ya no puede haber -h en la entrada

if(exists($params{'-r'})) { 
    if (scalar (@ARGV) == 1) {
        $consulta = 1;
        
    } elsif (scalar (@ARGV) == 2) {
        if (exists($params{'-w'})) {
            # body...
            $write = 1;
        } else {
            error_parametros();
        }

    } else {
        error_parametros();
    }

    # exit 0;
} elsif(exists($params{'-s'})) { 
    if (scalar (@ARGV) == 1) {
        $stats = 1;
        
    } elsif (scalar (@ARGV) == 2) {
        if (exists($params{'-w'})) {
            # body...
            $write = 1;
        } else {
            error_parametros();
        }

    } else {
        error_parametros();
    }

    # exit 0;
} else {
    error_parametros();
}

sub get_aniomes {


    my ($texto) = @_;
    # input, cantidad de pares a encontrar

    # salida, lista de anios meses

    while ($true) {
        # FIXME UNA Y todos es lo mismo
        print $texto;

        my $in = readline(*STDIN);

        if ($in){

            chomp $in;
            my @options = split / /, $in;

            # say $options[0];

            if (scalar @options != 0){
                return @options;
            }         
        } else {
            say 'Debe ingresar por lo menos un caracter';
        }

    }

}


sub get_archivos_carpetas {
    # http://linuxpoison.blogspot.com.ar/2013/01/perl-script-reading-list-of-files-from.html
    my ($nombre_carpeta) = @_;

    opendir(DIR, $nombre_carpeta) || die "Problem reading the dir. \n";

    #@filelist = readdir(DIR);
    my @filelist = ();
    my $filename;
    while ($filename = readdir(DIR)) {
        # acá hay que filtrar . y ..
        if ($filename ne '.' and $filename ne '..') {
            # print $filename , "\n";
            push (@filelist,$filename);
        }
    }
    closedir(DIR);
    return @filelist;
}



sub filtrar {
    # input: a list of files
    # out: all files that matches input
    # opciones
    my (@archivos) = (@_);
    # my (@archivos) = @_;
    my $result = una_varias_todas();

    my @filtered_list = ();

    if ($result eq (MYENUM)[UNA]){
        say 'una, no debería existir esto, es lo mismo que varias';
        
        get_aniomes(); # pedimos solo una
        # pido un anio mes

    } elsif ($result eq (MYENUM)[VARIAS]) {
        say 'varias'; # pedimos mas de una
        # pido un anio mes anio mes anio mes ...
        my @filtros = get_aniomes('Ingrese los filtros como aniomes (separados por espacios): ');
        
        # my $archivo; my $filtro;
        foreach my $archivo (@archivos){
            foreach my $filtro (@filtros){
                # say $filtro . ' ' . $archivo;
                #if ($archivo =~ '\w*_'.$filtro.'\$'){
                if ($archivo =~ "\\w*_$filtro\$"){
                    # agregamos solo los que pasan el filtro
                    # if (not exists($filtered_list{$archivo}) {

                    # }
                    if (not grep $_ eq $archivo, @filtered_list ){
                        push (@filtered_list, $archivo);

                    }

                    # say 'paso' . $filtro . ' ' . $archivo;
                }
            }
        }
        return @filtered_list;

    } elsif ($result eq (MYENUM)[TODAS]) {
        # NoFilter
        say 'todas';     
        return @archivos;
    }
}

sub filtrar_oficina {
    # input: a list of files
    # out: all files that matches input
    # opciones
    my (@archivos) = (@_);
    # my (@archivos) = @_;
    my $result = una_varias_todas();

    my @filtered_list = ();

    if ($result eq (MYENUM)[UNA]){
        say 'una, no debería existir esto, es lo mismo que varias';
        
        get_aniomes(); # pedimos solo una
        # pido un anio mes

    } elsif ($result eq (MYENUM)[VARIAS]) {
        say 'varias'; # pedimos mas de una
        # pido un anio mes anio mes anio mes ...
        my @filtros = get_aniomes('Ingrese los filtros como oficina (separados por espacios): ');
        
        # my $archivo; my $filtro;
        foreach my $archivo (@archivos){
            foreach my $filtro (@filtros){
                # say $filtro . ' ' . $archivo;
                #say '/\w*'."$filtro".'_\d+\b';
                #if ($archivo =~ "$filtro".'_\d+\b'){
                if ($archivo =~ "^$filtro\_"){
                    # agregamos solo los que pasan el filtro
                    if (not grep $_ eq $archivo, @filtered_list ){
                        push (@filtered_list, $archivo);

                    }
                    # say 'paso ' . $filtro . ' ' . $archivo;
                }
            }
        }
        return @filtered_list;

    } elsif ($result eq (MYENUM)[TODAS]) {
        # NoFilter
        say 'todas';     
        return @archivos;
    }
}

sub add_if_exist_hash {
    # variables
    # my ($hash, $key, $value) = (@_);
    #my %hash = %{shift()};
    my $hash = shift;
    my $key = shift;
    my %value = %{shift()};
    
    # if (not value in hash){
    #     $hash{} = array
    # }

    # my $incoming_hash_ref = shift;
    # $incoming_hash_ref->{'e'} = 'f';
    
    if (not exists $hash->{$key}){
        $hash->{$key} = [];
        # say 'No existe';
        #say "tamaño de el array". scalar @{$hash{$key}};
    } else {
        # say 'existe';
    }
    
    push(@{$hash->{$key}}, \%value);
    #say 'lo que está en el archivo'.%value{'central'};
    #say "tamaño de el array". scalar @{$hash->{$key}};
    # append llamada to list
}

sub elegir_filtro {
    my $nombre = shift;
    my $hash = shift;

    my @lista_posibilidades = keys %$hash; #FIXME

    say 'Seleccionar filtros por ' . $nombre;

    my $result = una_varias_todas();


    say 'A continuación opciones posibles: ';
    foreach (@lista_posibilidades){
        print $_.', ';
    }
    print "\n";
    
    if ($result eq (MYENUM)[VARIAS]) {
        my @filtros = get_aniomes('Ingrese los filtros usando las opciones atenriores (separados por espacios): ');
        return @filtros;
    } elsif (($result eq (MYENUM)[TODAS])) {
        return @lista_posibilidades;
    }

    # si varias () elegir

    # si todas
    #     retornar


}


sub hash_to_text {
    my $llamadat = shift;
    return ${$llamadat}{'central'} . ';' . 
    ${$llamadat}{'agente'} . ';' . 
    ${$llamadat}{'umbral'} . ' ' . 
    ${$llamadat}{'tipo_de_llamada'} . ';' .
    ${$llamadat}{'inicioLlamada'} . ';' .
    ${$llamadat}{'tiempo_de_conv'} . ';' .
    ${$llamadat}{'AreaA'} . ';' . 
    ${$llamadat}{'NumeroA'} . ';' .
    ${$llamadat}{'PaisB'} . ';' .
    ${$llamadat}{'AreaB'} . ';' .
    ${$llamadat}{'NumeroB'} . ';' .
    ${$llamadat}{'FechaArchivo'};
}

while ($true) { # para hacer mas de una consulta

    if ($consulta){

        my @salida = ();
        my @potenciales;
        my @archivos_filtros = get_archivos_carpetas($PROCDIR);
        
        say "filtros por oficina";
        @archivos_filtros = filtrar_oficina(@archivos_filtros);
        say "Filtros por aniomes";
        @archivos_filtros = filtrar(@archivos_filtros);

        # @archivos_filtros = filtrar(@archivos_filtros);

        if (scalar @archivos_filtros == 0){
            say "Warning: La selección de filtros no dejó ningún archivo para consultar."
        }

        # foreach (@archivos_filtros){
        #     say $_;
        # }

        # para cada línea
        # Creamos los 6 hashes
        my  %porCentral;
        my  %porAgente;
        my  %porUmbral;
        my  %porTipoLlamada;
        my  %porTiempoConv;
        my  %porNumerA;
        my @todos = ();

        foreach my $archivo (@archivos_filtros){
            # abrir el archivo
            # iteramos y llenamos 5 ha
            my $file = catfile($PROCDIR, $archivo);
            say 'abrí archivo ' . $file;
            
        # abrimos el archivo
            open(my $data, '<', $file) or 
            die "No se pudo abrir el arhcivo '$file' $!\n";
            


            while (my $line = <$data>) {
                chomp $line;

                # separar líneas
                my @fields = split ";" , $line;
                #say '      linea';

                #say $fields[2];

                # modelamos la llamada
                # 0centra
                # 1algente
                # 2idumbral
                # 3Tipo de llamada
                # 4Inicio de llamada
                # 5Tiempo
                # 6AreaA
                # 7NumeroA
                # 8PaisB
                # 9AreaB
                # 10NumeroB
                # 11Fecha
                my  %llamada;
                $llamada{'central'} = $fields[0];
                $llamada{'agente'} = $fields[1];
                $llamada{'umbral'} = $fields[2];
                $llamada{'tipo_de_llamada'} = $fields[3];
                $llamada{'tiempo_de_conv'} = $fields[5];
                $llamada{'NumeroA'} = $fields[6] . $fields[7];
                
                $llamada{'inicioLlamada'} = $fields[4];
                $llamada{'AreaA'} = $fields[6];
                $llamada{'NumeroA'} = $fields[7];
                $llamada{'PaisB'} = $fields[8];
                $llamada{'AreaB'} = $fields[9];
                $llamada{'NumeroB'} = $fields[10];
                $llamada{'FechaArchivo'} = $fields[11];
                



                # push (@todos, \%llamada);
                push(@todos, hash_to_text(\%llamada));

                # cargamos los hashes
                add_if_exist_hash(\%porCentral, $llamada{'central'}, \%llamada);
                add_if_exist_hash(\%porAgente, $llamada{'agente'}, \%llamada);
                add_if_exist_hash(\%porUmbral, $llamada{'umbral'}, \%llamada);
                add_if_exist_hash(\%porTipoLlamada, $llamada{'tipo_de_llamada'}, \%llamada);
                add_if_exist_hash(\%porTiempoConv, $llamada{'tiempo_de_conv'}, \%llamada);
                add_if_exist_hash(\%porNumerA, $llamada{'NumeroA'}, \%llamada);
            }
        }

        # usamos los filtros
        # say scalar @todos;
        my @filtros = (
            ['Central', \%porCentral],
            ['Agente', \%porAgente],
            ['umbral', \%porUmbral],
            ['Tipo de llamada', \%porTipoLlamada],
            ['NumeroA', \%porNumerA]
        );

        @potenciales = @todos;

        say 'Empezamos por los filtros: ';
        foreach my $filtro (@filtros ){
        # Tipos de filtros:
        #   Filtro por central (una, varias, todas)
        #   Filtro por agente (uno, varios, todos)
        #   Filtro por umbral (uno, varios, todos)
        #   Filtro por tipo de llamada (una, varias, todas)
        #   Filtro por numero A (área y numero de línea) (uno, varios, todos)

            my @tupla = $filtro;
            # say $tupla[0][1];
            # $tupla[0][0] -> nombre
            # $tupla[0][1] -> hash
            my @filtros = elegir_filtro($tupla[0][0], $tupla[0][1]); # me da una lista de claves de has
            
            #TODO
            # sale_filtro = Todas las llamadas de esos filtros (hay repetidos);
            my @sale_filtro = ();
            foreach my $filtro (@filtros){
                foreach my $llamadas ($tupla[0][1]{$filtro}){
                    #say @{$llamada}[0];
                    foreach my $llamadat (@{$llamadas}){
                        push(@sale_filtro, hash_to_text($llamadat));
                    }
                    #if (not grep $_ equ $llamada }) { 
                    #}
                    # falta chequear duplicados #FIXME
                }
            }

            # foreach my $llamadat (@sale_filtro){
            #     #say hash_to_text($llamadat);
            #     say $llamadat;
            # }

            
            # para cada potencia en potencial:
            foreach my $llamada_potencia (@potenciales){
            
                # if (not grep $_ eq $archivo, @filtered_list ){
                if (grep $_ eq $llamada_potencia, @sale_filtro){
                    if (not grep $_ eq $llamada_potencia, @salida){
                        push (@salida, $llamada_potencia);
                    }
                }            #     sii está en salida en sale_filtro y no está en salida:
            #         agregar en salida:
                
            }

            @potenciales = @salida;
            # si la salida está vacia -> warning la selección quedó vacía
            #TODO

            #itero uno por uno y me fijo si está.

        }
        #   Filtro por tiempo de conversación (rango)

        #TODO: imprimir todas las llamadas
        foreach my $llamadat (@potenciales){
            #say hash_to_text($llamadat);
            say $llamadat;
        }

        say "    -\nEmpieza nueva consulta";
    }

}
 

# cada uno de estos fultros va a ser un hash.
# después aplicamos los filtros y metemos todo en un set. Y printiamos el set.

# say "What is your name? ";
# my $name = <STDIN>;
# chomp $name;

# say "Hello $name, how are you?";

# Parse options (-h, -r, -w, -s)


#FIXME ¿como pongo los varios filtros que me pida?

# -h no puede tener otro comando
# -r solo puede estar con -w
# -s solo puede estar con -w

# my $filename = "$MAEDIR/CdP.mae";

# open(my $fh, '<:encoding(UTF-8)', $filename)
#   or die "Could not open file '$filename' $!";
 
# while (my $row = <$fh>) {
#   chomp $row;
#   print "$row\n";
# }

